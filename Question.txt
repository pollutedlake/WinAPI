※ 차후 진행하게 될 이자기에 대한 주의점 + 방어멘트 + 면접 요령은
이자기 시즌에 다뤄준다.

# 자기소개 #

- 패스

# 이력서 검증 #

- 패스

# 자기소개서 검증 #

- 패스

# 기술 면접

==================

1. 입사 동기?
ㄴ 왜 너를 뽑아야 될까? 어필해보시오.
ㄴ 최대한 범용적으로, 회사 이름을 다르게 바꿔도 이질감 없도록

2. 야근 여부와 의지에 대해 - 생각보다 많이 나옴
ㄴ 할 수 있습니다, 회사가 시키면 하겠습니다 - 안됨
ㄴ 만약 야근을 할 때가 된다면, 회사에 열심히 이바지해서...

3. 외국어 할 줄 아는가?
ㄴ 리딩 부분에서는 업무에 지장이 없습니다, 같은.

★
4. 본인의 코딩 스타일은 어떤가? (의도는 협업능력 파악)
ㄴ 추천하는 단어: 협업, 도서

5. (4번에서 이어질 수 있다)그렇다면 다른 사람의 코드를 리딩하는 실력은 어느 정도라고 생각하는가?
ㄴ 겸손이 필요하다.
ㄴ 제가 배우는 단계여서 아직은 부족하지만, 그래도 언급을 하자면 중간 정도 단계라고 생각한다.
   헤더에서 변수나 구조체 객체 등을 보고, 함수 이름을 봐서 어떤 동작을 하는지 파악한 다음 cpp 파일을 본다.

6. 절차지향과 객체지향의 차이점에 대해서 알고 있는지?
ㄴ 언어를 반드시 언급한다.
ㄴ C언어, 구조적 프로그래밍, 함수 기반 프로그래밍
ㄴ C++, 객체지향 프로그래밍, 오브젝트 파일이 꼭 나와야 된다.

7. 할로우 나이트, 혹은 메가맨 같은 플랫포머 게임을 해본적이 있는가? - 당연히 O가 나온다.
해본 적이 있다면 이와 비슷한 장르의 게임 충돌 처리는 어떻게 하면 효율적일까?
ㄴ 제가 생각하기에, 메가맨 같은 게임의 충돌처리는 픽셀 충돌인 것 같습니다.
ㄴ 여기에 더해, 기반 지식을 어필하자. 기본적으로 2D 게임의 충돌 방식에는 AABB, OBB, Colider 픽셀 충돌
	방식이 있으며, 기본적으로 메가맨의 충돌처리는 픽셀 충돌인 것으로 알고 있습니다.
	ㄴ 근거도 어필하자. 왜냐하면...

★★★★★
8. C/C++을 (C#) 사용했다고 알고 있는데, 사용한 이유는?
ㄴ 이 질문 내부에 학원 검증이 들어가있다.
ㄴ worst. 학원에서 담당 교수님이 가르쳐서요.
ㄴ 키워드: C#이나 Java를 언급하면 좋다. - C#은 잠시 내려놓고 Java가 타겟
ㄴ Java로 못하는 것을 C++로는 할 수 있다.
ㄴ 상용 엔진의 내부 구조는 보통 C/C++과 DirectX로 이루어져 있기 때문에.

9. 라이프 사이클에 대해서 이야기해 봐라. (변수, 함수)
ㄴ 언급이 없다면 - 우리가 어필한다. (변수에 대한 것? 혹은 함수에 대한 것?) 정 모르면 변수에 대해 언급.
ㄴ Allocate -> Release -> Memory Pool
ㄴ 변수의 메모리가 확보된 시점부터 -> 해제되어 -> 그 변수에 사용된 메모리가 가용 메모리로 반환된 시점까지

(중요하다)
10. 게임 프로그래머가 되고 싶은 이유는?
ㄴ 상황을 봐서 대답해야 한다. 
ㄴ 나의 경험담, 어릴 적을 언급해보면 좋을 것 같다.
ㄴ worst. 정보, 게임을 잘해서, 하고 싶어서 

★
11. 그러면 어떤 노력을 했는가?
ㄴ 기술적 질문으로 내려왔다.
ㄴ 언어 얘기는 반드시, 엔진 얘기도 반드시 나와야 한다. (자랑 찬스)
ㄴ 서브 언어를 언급할 때는 상황을 봐야 한다. C#, Java, Python 등등...

12. 그럼 읽고 있는 전공책이 있는가?
ㄴ C/C++이 나왔다 싶으면 모던 C++을 언급한다.
ㄴ 용책, 해골책, 물방울책, 노을책, 공룡책
ㄴ 순서대로 DirectX9, 10, 11, 12, 운영체제
ㄴ 뭐가 들어가는지는 깊이가 얕아도 상관없다. 대답은 하기 나름.

13. 동료들과 의사 소통에 차이가 있을 때 본인의 대처 방식은?
ㄴ 추상적으로 이야기하지 말고, 구체적으로 해야 한다.
ㄴ 우리한테 타당성이 있으려면, 근거와 결과가 있어야 한다.
	ㄴ 원인이 필요하다.
ㄴ 결론적으론 근거, 결과, 원인을 언급하여 나의 생각을 뒷받침.

14. 객체지향의 5대 설계원칙에 대해 설명해봐라.
ㄴ 단일 책임 원칙 (Single Responsiblity Principle)
ㄴ 개방-폐쇄 원칙 (Open Closed Principle)
ㄴ 리스코프 치환 원칙 (Liskov Substitution Principle)
ㄴ 인터페이스 분리 원칙 (Interface Segregation Principle)
ㄴ 의존 역전 원칙 (Dependency Inversion Principle)

15. 스택과 힙의 차이점 및 설명 -> 용량 -> 가상 메모리?
ㄴ 스택 - 선입후출, 지역변수, 함수에 대한 주소값
ㄴ 힙 - 사용자가 관리해야 함, 램의 약 80%를 사용할 수 있음
ㄴ OS로 나아간다면, 자연스럽게 빠진다.
-> 더 나아간 질문 : 데이터 스트럭쳐에 대해 설명해 봐라.

16. 벨류 타입과 레퍼런스 타입에 대해 설명해 봐라.
ㄴ 포인터 관련이다. 질문이 엄청 깊어질 수 있다.
ㄴ 단점
ㄴ int** &number = &pa;
	ㄴ 연산이 많이 들어가는 널 체크가 빠진다.
	ㄴ C++11은 안 되지만, C++17부터 가능하다.
	ㄴ 질문의 의도는, 최신 언어에 대해 관심이 있는가이다.

17. 프로그래밍의 여러 분야 중, 본인이 가장 관심있고 해보고 싶은 분야가 있다면?
ㄴ 클라이언트는 언어에 대한 이해, 그래픽스에 대한 이해가 필요.
	ㄴ 그래픽스에 대한 하위(DirectX나 GDI+ 같은)
ㄴ 서버는 데이터베이스를 관리할 수 있는 효율적인 툴을 얘기하면 좋다.
ㄴ 요점은, 대답할 수 있는 것.
ㄴ 만약 대답하기 애매하면? 최적화 프로그래밍으로 빠진다.
	ㄴ 파생 질문이 언어, 알고리즘, 자료구조로 빠진다.
ㄴ worst. 클라이언트, 서버.

★★★★★ 역질문 ★★★★★
18. 마지막으로 회사에 질문할 것이 있는지? - 최소 3개 이상 준비
ㄴ 어느 회사를 가든 면접 끝에 무조건 나오는 질문이다. 매우 중요하다.
ㄴ 괜찮은 것 1. 제가 감히 합격을 하게 된다면, 어떤 업무를 하게 되나요?
ㄴ worst. 사수 있나요?
ㄴ 정말 마지막, 면접 끝나고 - 제가 면접 경험이 부족해서, 혹시 이번 면접에서 저에게
   부족한 것이 있다면 알려주시면 감사하겠습니다. 하고 정중하게 질문해본다.

19. C++과 C#의 차이점에 대해 설명해 보시오.
ㄴ 컴파일러의 유무
ㄴ 메모리 관리
ㄴ 만약 엔진에 관련된 질문이라면 - 컴파일러의 유무는 좋지 않다.
ㄴ C++은 독립적인 언어이고, C#은 .net의 의존도가 높다. 같은.
ㄴ 파생 질문 - 각 언어의 배열 선언 방법은?
	ㄴ C++ : int number[];
	ㄴ C#  : int[] number = new int[];

20. 구조체와 클래스의 차이
ㄴ 어떤 언어로 말할까요? (C++, C#)
ㄴ C++: 접근 제어 지시자 (public, private) 차이다.
	ㄴ 너무 추상적이라고 말하면? : 어셈블리로 들어간다.
ㄴ C#: 박싱과 언박싱 차이다.

21. 엡실론이 무엇인가? 왜 사용하는가? 왜 오차가 날 수 있는가?
ㄴ 부동소수는 기본적으로 실수를 정확하게 표현하는 게 불가능
ㄴ 이유는 수학적으로 실수는 무한한 반면 이 실수를 유한한 비트로 표현해야 한다.
ㄴ 그렇기 때문에 컴퓨터는 어쩔 수 없이 근사값으로 처리한다.

- 이게 부동소수점 반올림 오차
ㄴ 컴퓨터는 실수를 이진수의 형태로 저장
ㄴ 이러한 특징 떄문에 오차범위가 발생하고 정확한 계산을 위해서는 상수값이 반드시 필요.

22. 오버로딩과 오버라이딩의 차이점
ㄴ 중복 정의와 재정의라는 차이점이 있다.
ㄴ 오버로딩: 반환 타입에 관계 없이 이름이 같고 인자가 다른 함수의 중복 정의
ㄴ 오버라이딩: 상속 관계에서 부모 클래스에서 virtual로 정의한 같은 이름의 함수를
              자식 클래스에서 다시 정의

23. 다중 상속에 대한 질문 (C++ / C# -> 1. 가능한가? 2. 왜 안되는가?)
ㄴ 키워드1. 다이아몬드 구조 - 소멸자의 호출을 정의하기 매우 애매하다.
ㄴ 키워드2. 그렇기 때문에 고유 객체성이 깨져 인클루드 가드가 꺠진다.
ㄴ - 링크 오류가 뜬다.

24. virtual 키워드의 동작 방식은?
ㄴ 면접 단골 문제
ㄴ 가상 테이블에서 참조하고 런타임 직전에 동작한다.

25. virtual 멤버 함수에 대해서 설명해보시오.
ㄴ 오버라이딩이 될 수 있는가 아닌가.
ㄴ 버츄얼 함수가 가리키고 있는 인스턴스에 따라 내가 실행할 함수를 정의한다.
ㄴ 이 인스턴스 타입이 모이고 있는 영역을 가상함수 테이블이라고 한다.

26. 가상함수 table이 무엇인가?
ㄴ 인스턴스 타입에 의해 실행되는 함수들의 함수 포인터가 나열된 table이다.

27. New / Malloc 개념과 차이점? 그리고 table과 연관관계는?
ㄴ 인스턴스를 자동으로 호출해주냐 안해주냐 차이.
ㄴ new - 생성자를 자동 호출하기 떄문에 가상함수 테이블을 만들 수 있다.

28. 순수 가상함수를 만들면 메모리상에 몇 바이트를 차지하는가? - 여기부터 중급 질문
ㄴ 놓치면 아까운 문제
ㄴ 정답: 인스턴스를 만들기 전에는 아무런 공간도 차지하지 않는다.

29. 가상함수 테이블을 만들 떄, 메모리상에서 일어나는 과정을 설명해보시오. 
ㄴ 스타트 + 중소에서 -> 연봉 오르는 질문 // 중견 + 대기업 => 디폴트
ㄴ 키워드: 결합, 바인딩(정적 바인딩과 동적 바인딩)
ㄴ 런타임 시 가상함수 테이블이 결합되므로, 호출 시에
   인스턴스 테이블에 맞게끔 정적 바인딩을 실행.
   런타임이 되면 동적 바인딩으로 바뀌며, 일반 함수들은 정적 결합.

30. 컴파일 순서에 대해 이야기해 보시오.
ㄴ 전처리기 - 컴파일러 - 어셈블리 - 오브젝트 파일 생성 - 링킹 - 실행 파일
ㄴ 우선, 전처리기에서 사용자가 작성한 소스 파일에서 필요한 정보를 수집합니다.
ㄴ 그 다음 컴파일러에서...
ㄴ 요약하는 것보다 여기서 지식을 뽐내는 게 좋다.

31. STL이란?
ㄴ 프로그래밍에 필요한 자료구조나 알고리즘을 효율적으로 쓰기 위해 템플릿 라이브러리로 만든
   데이터 컨테이너.

32. 포인터가 무엇인가?
ㄴ 변수나 함수의 주소값을 저장하는 변수.

★★★★★
33. 벡터와 리스트의 차이점은?
ㄴ 요점은 삽입 삭제에 용이하냐 아니냐다.
ㄴ 벡터는 선형이고 연속적이기 떄문에, 원소를 중간에 삽입했을 경우 다른 원소를 하나씩 밀거나 당기는
   작업이 필요하다.

34. 벡터에 처음 할당된 메모리 이상의 데이터가 들어갔다고 가정하면 어떤 상황이 발생할까?
ㄴ 오류 메세지가 나와야 한다.
ㄴ 일반적으로 capacity에 대한 오류 메세지가 들어온다. resize 같은 선행 처리를 해줘야 한다.

★★★
35. 회사에서 야근을 하다가 오류를 발견했다. (본인이 판단했을 때 심각하다고 느낀)
    이때, 본인은 어떻게 대처할 것인가?
ㄴ 즉시 팀장님에게 연락을 할 것이다.

연봉 오르는 질문
36. 맹글링이란?
ㄴ 함수 
ㄴ 익스플로어 링킹?

37. 명시적 링킹이란?
ㄴ 

friend 키워드
상속 관계 무시
friend로 묶여있는 객체들에게만 데이터 전달
양방향이 아니라 단방향으로만 적용
복잡한 상속 구조 / 효율적인 구조를 설계할 때 많이 등장한다.
friend class 
== 봉인 ==


로우레벨 / 하이레벨 구분
언매니지드 / 매니지드
메모리접근
OS 프로젝트의 메모리를 나도 같이 쓸 수 있느냐 없느냐



=======================================================

회사에서 일을 하려면?

회사에서 일을 하는 자세의 문제
1. 마음가짐
ㄴ 예를 들어 무언가가 안 되면?
	ㄴ A를 하려 하는데 잘 되지 않는다. 혹시 이걸 해결하기 위해 참고할만한 것이 있는가?
	ㄴ 질문 수준을 들어봐도, 역량이 보인다.

프로그래머가 아니라 게임 개발자라면 가져야 할 역량
2. 공통 역량
ㄴ 끈기

게임 프로그래머를 게임 프로그래머답게 만드는 역량
3. 전문 역량
ㄴ 갖춰야 될 기술적인 역량들.